<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="shortcut icon"
      href="https://user.uploads.dev/file/8c7563d0ece7c9ed36c8a83f8361a7a7.webp"
      type="image/x-icon"
    />
    <meta
      name="description"
      content="Combine multiple adult rewriting modes at once. Convert text into explicit, erotic, BDSM, or romantic styles with a single click."
    />
    <meta
      name="keywords"
      content="AI, text converter, text rewriter, NSFW, erotic, adult, BDSM, romance"
    />
    <meta name="author" content="Mosberg" />
    <title>AI Text Converter and Rewriter Moss NSFW</title>
    <style>
      * {
        box-sizing: border-box;
      }

      :root {
        --bg-1: #120b10;
        --bg-2: #1f1116;
        --bg-3: #2a141c;
        --card: #1b1418;
        --card-2: #25161d;
        --text: #f2e9e4;
        --text-muted: #c2b6b0;
        --accent: #c9344c;
        --accent-2: #f2b57e;
        --border: rgba(242, 233, 228, 0.15);
        --shadow: 0 12px 30px rgba(0, 0, 0, 0.4);
        --transition: 160ms ease;
      }

      body {
        margin: 0;
        padding: 1.5rem;
        color: var(--text);
        background:
          radial-gradient(1200px 600px at 10% 0%, #2a141c, transparent 60%),
          radial-gradient(900px 500px at 90% 20%, #2f1a21, transparent 55%),
          linear-gradient(135deg, var(--bg-1), var(--bg-2) 40%, var(--bg-3));
        font-family: "Cormorant Garamond", "Garamond", "Georgia", serif;
      }

      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background-image:
          linear-gradient(
            120deg,
            rgba(255, 255, 255, 0.03) 0%,
            rgba(255, 255, 255, 0.01) 40%,
            transparent 70%
          ),
          repeating-linear-gradient(
            90deg,
            rgba(255, 255, 255, 0.03),
            rgba(255, 255, 255, 0.03) 1px,
            transparent 1px,
            transparent 6px
          );
        opacity: 0.4;
        pointer-events: none;
        z-index: -1;
      }

      h1 {
        text-align: center;
        font-size: clamp(2rem, 4vw, 3.2rem);
        letter-spacing: 0.06em;
        margin: 0 0 1.5rem 0;
        text-transform: uppercase;
      }

      .subtitle {
        text-align: center;
        margin: 0 auto 2rem auto;
        max-width: 760px;
        color: var(--text-muted);
        font-size: 1.05rem;
      }

      .container {
        max-width: 980px;
        margin: 0 auto;
        display: grid;
        gap: 1.5rem;
      }

      .card {
        background: linear-gradient(145deg, var(--card), var(--card-2));
        border: 1px solid var(--border);
        border-radius: 18px;
        box-shadow: var(--shadow);
        padding: 1.5rem;
      }

      .card-title {
        text-transform: uppercase;
        letter-spacing: 0.14em;
        font-size: 0.8rem;
        color: var(--accent-2);
        margin-bottom: 1rem;
      }

      .mode-toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 1rem;
      }

      .mode-toolbar .summary {
        font-size: 0.95rem;
        color: var(--text-muted);
      }

      .mode-toolbar button {
        background: transparent;
        color: var(--accent-2);
        border: 1px solid var(--accent-2);
        padding: 0.4rem 0.8rem;
        border-radius: 999px;
        cursor: pointer;
        transition: var(--transition);
        font-family: "Jost", "Trebuchet MS", sans-serif;
      }

      .mode-toolbar button:hover {
        background: var(--accent-2);
        color: #2a151b;
      }

      .mode-grid {
        display: grid;
        gap: 1.5rem;
      }

      .mode-category {
        border-top: 1px solid var(--border);
        padding-top: 1rem;
      }

      .mode-category h3 {
        font-size: 1rem;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        color: var(--accent-2);
        margin: 0 0 0.75rem 0;
      }

      .mode-list {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 0.75rem;
      }

      .mode-item {
        display: flex;
        align-items: center;
        gap: 0.6rem;
        padding: 0.6rem 0.75rem;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.2);
        cursor: pointer;
        transition: var(--transition);
      }

      .mode-item:hover {
        border-color: var(--accent);
        transform: translateY(-2px);
      }

      .mode-item input {
        accent-color: var(--accent);
        width: 16px;
        height: 16px;
      }

      .mode-item span {
        font-family: "Jost", "Trebuchet MS", sans-serif;
        font-size: 0.95rem;
        color: var(--text);
      }

      .selected-tags {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin-top: 0.75rem;
      }

      .selected-tag {
        background: rgba(201, 52, 76, 0.2);
        color: var(--text);
        border: 1px solid rgba(201, 52, 76, 0.6);
        padding: 0.25rem 0.6rem;
        border-radius: 999px;
        font-family: "Jost", "Trebuchet MS", sans-serif;
        font-size: 0.85rem;
      }

      textarea {
        width: 100%;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: rgba(0, 0, 0, 0.2);
        color: var(--text);
        padding: 1rem;
        font-family: "Jost", "Trebuchet MS", sans-serif;
        font-size: 0.98rem;
        transition: var(--transition);
      }

      textarea:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px rgba(201, 52, 76, 0.2);
      }

      .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: center;
      }

      .primary-btn {
        background: linear-gradient(120deg, var(--accent), #e65f75);
        color: #120b10;
        font-family: "Jost", "Trebuchet MS", sans-serif;
        font-size: 1rem;
        font-weight: 600;
        padding: 0.8rem 1.6rem;
        border: none;
        border-radius: 999px;
        cursor: pointer;
        transition: var(--transition);
        box-shadow: 0 8px 20px rgba(201, 52, 76, 0.35);
      }

      .primary-btn:hover {
        transform: translateY(-2px);
      }

      .ghost-btn {
        background: transparent;
        color: var(--text-muted);
        border: 1px solid var(--border);
        padding: 0.6rem 1rem;
        border-radius: 999px;
        font-family: "Jost", "Trebuchet MS", sans-serif;
        cursor: pointer;
      }

      .ghost-btn:hover {
        border-color: var(--accent-2);
        color: var(--accent-2);
      }

      .controls {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
        align-items: center;
      }

      .hidden {
        display: none;
      }

      .note {
        color: var(--text-muted);
        font-size: 0.9rem;
      }

      @media (max-width: 640px) {
        body {
          padding: 1rem;
        }

        .card {
          padding: 1.2rem;
        }

        .mode-list {
          grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        }
      }
    </style>
  </head>
  <body>
    <h1>AI Text Converter and Rewriter Moss NSFW</h1>
    <p class="subtitle">
      Choose multiple adult modes and blend them together in a single rewrite. Only consensual,
      adult themes are supported.
    </p>

    <div class="container">
      <section class="card">
        <div class="card-title">Mode Blend</div>
        <div class="mode-toolbar">
          <div class="summary" id="modeSummary">Select at least 1 mode.</div>
          <div>
            <button type="button" id="selectAllBtn">Select all</button>
            <button type="button" id="clearAllBtn">Clear</button>
          </div>
        </div>
        <div id="modeGrid" class="mode-grid"></div>
        <div class="selected-tags" id="selectedTags"></div>
      </section>

      <section class="card">
        <div class="card-title">Custom Direction</div>
        <textarea
          id="customInstructionEl"
          placeholder="Optional: add an extra adult tone or constraint, like 'make it more tender'"
          rows="3"
        ></textarea>
        <p class="note">Custom instructions are combined with the selected modes.</p>
      </section>

      <section class="card">
        <div class="card-title">Input Text</div>
        <textarea
          id="inputTextEl"
          placeholder="Paste the text you want to convert."
          rows="6"
        ></textarea>
      </section>

      <section class="card">
        <div class="card-title">Output Text</div>
        <div class="actions">
          <button class="primary-btn" id="generateBtn" onclick="startGenerate()">
            Convert Text
          </button>
          <button class="ghost-btn" id="continueBtn" onclick="generate()" disabled>Continue</button>
          <button class="ghost-btn" id="retryBtn" onclick="retryGenerate()" disabled>Retry</button>
        </div>
        <div id="loaderEl" class="note"></div>
        <textarea
          id="responseEl"
          placeholder="Converted text will appear here."
          rows="10"
        ></textarea>
        <div class="controls">
          <button class="ghost-btn" id="bottomContinueBtn" onclick="generate()" disabled>
            Continue
          </button>
          <button class="ghost-btn" id="bottomStopBtn" hidden>Stop</button>
        </div>
        <button class="ghost-btn" id="stopBtn" hidden>Stop</button>
        <button id="responseDeleteBtn" class="ghost-btn" hidden onclick="handleDelete()">
          Delete output
        </button>
      </section>
    </div>

    <textarea id="selectedInstructionEl" class="hidden"></textarea>

    <script>
      // Mode data with categories, labels, and instructions
      const modesData = [
        // Erotic Styles
        {
          name: "romantic",
          label: "Romantic & Tender",
          category: "Erotic Styles",
          instruction:
            "Make the text deeply romantic and emotionally tender. Focus on feelings, emotional connection, and intimate affection."
        },
        {
          name: "sensual",
          label: "Sensual & Slow",
          category: "Erotic Styles",
          instruction:
            "Rewrite with slow, deliberate pacing. Emphasize sensory details—touch, scent, warmth. Make it feel languid and immersive."
        },
        {
          name: "passionate",
          label: "Passionate & Intense",
          category: "Erotic Styles",
          instruction:
            "Infuse with raw passion and desire. Use stronger verbs, shorter sentences during moments of intensity. Make the emotional and physical connection feel urgent and powerful."
        },
        {
          name: "teasing",
          label: "Playful & Teasing",
          category: "Erotic Styles",
          instruction:
            "Add playful banter, teasing, and light flirting. Keep the tone fun and flirty with a sense of anticipation and build-up."
        },
        {
          name: "elegant",
          label: "Elegant & Poetic",
          category: "Erotic Styles",
          instruction:
            "Use refined, poetic language. Create beauty through metaphor and graceful phrasing. Make the writing feel sophisticated and artistic."
        },

        // BDSM and Power
        {
          name: "dominant",
          label: "Dominant Female",
          category: "BDSM and Power",
          instruction:
            "Write from a female dominant perspective. Use commanding language, assertiveness, and control dynamics. The dominant woman is in charge and her pleasure is paramount."
        },
        {
          name: "submissive",
          label: "Submissive",
          category: "BDSM and Power",
          instruction:
            "Write from a submissive perspective, emphasizing surrender, service, and the pleasure of obedience. The submissive desires to please and follow commands."
        },
        {
          name: "dominant_male",
          label: "Dominant Male",
          category: "BDSM and Power",
          instruction:
            "Write from a male dominant perspective. Use authoritative language, control, and possessiveness. The dominant takes charge and demands submission."
        },
        {
          name: "bratty",
          label: "Bratty & Defiant",
          category: "BDSM and Power",
          instruction:
            "Include playful defiance and bratty behavior. The submissive challenges the dominant lightly, seeking punishment or attention while ultimately submitting."
        },
        {
          name: "praise",
          label: "Praise & Affirmation",
          category: "BDSM and Power",
          instruction:
            "Focus heavily on verbal praise, affirmation, and reassurance. The dominant reinforces the submissive's worth and desirability with loving words."
        },

        // Sexual Acts
        {
          name: "oral_focus",
          label: "Oral Focus",
          category: "Sexual Acts",
          instruction:
            "Focus descriptions on oral pleasure and the sensations it brings. Emphasize the intimacy and power dynamics of giving and receiving oral stimulation."
        },
        {
          name: "intercourse_focus",
          label: "Intercourse Focus",
          category: "Sexual Acts",
          instruction:
            "Focus on penetrative sex. Describe the physical sensations, rhythm, and intimacy of intercourse in vivid detail."
        },
        {
          name: "foreplay",
          label: "Extended Foreplay",
          category: "Sexual Acts",
          instruction:
            "Extend the build-up with extensive foreplay. Include kissing, touching, massage, and gradual escalation. Make the anticipation as important as the act itself."
        },
        {
          name: "toys",
          label: "Toys & Accessories",
          category: "Sexual Acts",
          instruction:
            "Incorporate sex toys, restraints, blindfolds, or other accessories. Describe how these items enhance pleasure and deepen the experience."
        },

        // Tones and Atmospheres
        {
          name: "dirty_talk",
          label: "Dirty Talk",
          category: "Tones and Atmospheres",
          instruction:
            "Include explicit, arousing dialogue and verbal descriptions. The characters should vocalize their desires and pleasure openly."
        },
        {
          name: "sweet_whispers",
          label: "Sweet Whispers",
          category: "Tones and Atmospheres",
          instruction:
            "Use soft, intimate whispers and gentle verbal affection. The language should be loving and quiet, as if speaking directly into a lover's ear."
        },
        {
          name: "narrative",
          label: "Third Person Narrative",
          category: "Tones and Atmospheres",
          instruction:
            "Rewrite in third-person narrative form, describing the scene from an observer's perspective with rich detail."
        },
        {
          name: "first_person",
          label: "First Person POV",
          category: "Tones and Atmospheres",
          instruction:
            "Rewrite from first-person perspective, experiencing the events intimately through one character's eyes."
        },

        // Fantasy and Roleplay
        {
          name: "fantasy_creature",
          label: "Fantasy Creature",
          category: "Fantasy and Roleplay",
          instruction:
            "Incorporate fantasy elements—perhaps a supernatural lover (vampire, werewolf, fae, demon, etc.) with unique abilities and desires."
        },
        {
          name: "historical",
          label: "Historical Setting",
          category: "Fantasy and Roleplay",
          instruction:
            "Set the scene in a historical period (Victorian, Medieval, Renaissance, etc.). Use period-appropriate language and context."
        },
        {
          name: "office",
          label: "Office/Workplace",
          category: "Fantasy and Roleplay",
          instruction:
            "Create a workplace scenario with office politics, secret affairs, or professional tensions turning intimate."
        },
        {
          name: "strangers",
          label: "Strangers/Anonymous",
          category: "Fantasy and Roleplay",
          instruction:
            "Write about anonymous encounters or strangers meeting for a brief, intense connection without backstory or future commitment."
        }
      ];

      // Element references
      const modeGrid = document.getElementById("modeGrid");
      const selectedTags = document.getElementById("selectedTags");
      const modeSummary = document.getElementById("modeSummary");
      const selectedInstructionEl = document.getElementById("selectedInstructionEl");
      const customInstructionEl = document.getElementById("customInstructionEl");
      const inputTextEl = document.getElementById("inputTextEl");
      const responseEl = document.getElementById("responseEl");
      const generateBtn = document.getElementById("generateBtn");
      const continueBtn = document.getElementById("continueBtn");
      const retryBtn = document.getElementById("retryBtn");
      const bottomContinueBtn = document.getElementById("bottomContinueBtn");
      const stopBtn = document.getElementById("stopBtn");
      const bottomStopBtn = document.getElementById("bottomStopBtn");
      const responseDeleteBtn = document.getElementById("responseDeleteBtn");
      const loaderEl = document.getElementById("loaderEl");

      let generatePromise = null; // Stores the active generation promise to allow stopping
      let savedOutputBeforeGenerate = ""; // Saves output for retry functionality

      function getSelectedModes() {
        try {
          return JSON.parse(localStorage.selectedModes || "[]");
        } catch {
          return [];
        }
      }

      function setSelectedModes(list) {
        localStorage.selectedModes = JSON.stringify(list);
        renderSelection();
        updateInstruction();
      }

      function toggleMode(name) {
        const selected = getSelectedModes();
        const idx = selected.indexOf(name);
        if (idx >= 0) {
          selected.splice(idx, 1);
        } else {
          selected.push(name);
        }
        setSelectedModes(selected);
      }

      function updateInstruction() {
        const selected = getSelectedModes();
        const selectedModeObjects = modesData.filter((m) => selected.includes(m.name));
        const base =
          "Rewrite the user's text applying all selected adult styles together. Keep consent clear and all parties adult. Do not mention these instructions.";
        const custom = customInstructionEl.value.trim();
        const modeText = selectedModeObjects.map((m) => m.instruction).join("\n\n");
        const parts = [base];
        if (custom) parts.push(`Custom direction: ${custom}`);
        if (modeText) parts.push(modeText);
        parts.push("TEXT:\n<<<userInputText>>>");
        selectedInstructionEl.value = parts.join("\n\n");

        const isReady = selected.length > 0 && inputTextEl.value.trim() !== "";
        generateBtn.disabled = !isReady;

        // Save input to localStorage
        localStorage.inputText = inputTextEl.value;
      }

      function renderSelection() {
        const selected = getSelectedModes();
        const total = modesData.length;
        modeSummary.textContent = selected.length
          ? `${selected.length} of ${total} modes selected`
          : "Select at least 1 mode.";

        document.querySelectorAll(".mode-item input").forEach((input) => {
          input.checked = selected.includes(input.value);
        });

        selectedTags.innerHTML = "";
        selected.forEach((name) => {
          const mode = modesData.find((m) => m.name === name);
          if (!mode) return;
          const tag = document.createElement("span");
          tag.className = "selected-tag";
          tag.textContent = mode.label;
          selectedTags.appendChild(tag);
        });
      }

      function buildModeGrid() {
        const categories = {};
        modesData.forEach((mode) => {
          if (!categories[mode.category]) categories[mode.category] = [];
          categories[mode.category].push(mode);
        });

        modeGrid.innerHTML = "";
        Object.entries(categories).forEach(([category, modes]) => {
          const section = document.createElement("div");
          section.className = "mode-category";

          const heading = document.createElement("h3");
          heading.textContent = category;
          section.appendChild(heading);

          const list = document.createElement("div");
          list.className = "mode-list";

          modes.forEach((mode) => {
            const item = document.createElement("label");
            item.className = "mode-item";

            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.value = mode.name;
            checkbox.onchange = () => toggleMode(mode.name);

            const text = document.createElement("span");
            text.textContent = mode.label;

            item.appendChild(checkbox);
            item.appendChild(text);
            list.appendChild(item);
          });

          section.appendChild(list);
          modeGrid.appendChild(section);
        });
      }

      function loadSaved() {
        if (localStorage.inputText) {
          inputTextEl.value = localStorage.inputText;
        }
        if (localStorage.response) {
          responseEl.value = localStorage.response;
          continueBtn.disabled = false;
          bottomContinueBtn.disabled = false;
          responseDeleteBtn.hidden = false;
        }
        if (localStorage.customInstruction) {
          customInstructionEl.value = localStorage.customInstruction;
        }
      }

      async function generate() {
        if (generatePromise) return; // Prevent multiple concurrent generations

        const prompt = selectedInstructionEl.value.replace(
          "<<<userInputText>>>",
          inputTextEl.value
        );

        // UI State Update: Loading
        generateBtn.disabled = true;
        stopBtn.hidden = false;
        bottomStopBtn.hidden = false;
        continueBtn.disabled = true;
        bottomContinueBtn.disabled = true;
        retryBtn.disabled = true;
        responseEl.readOnly = true; // Lock editing while generating
        responseDeleteBtn.disabled = true;
        loaderEl.textContent = "Rewriting text...";

        try {
          // Use the global generateText function
          generatePromise = generateText({
            instruction: prompt,
            onChunk: (data) => {
              // Append new text chunk to the textarea
              responseEl.value += data.textChunk;
              // Auto-scroll to bottom
              responseEl.scrollTop = responseEl.scrollHeight;
            }
          });

          await generatePromise;

          // UI State Update: Success
          responseDeleteBtn.hidden = false;
          responseDeleteBtn.disabled = false;
        } catch (err) {
          console.error("Generation failed:", err);
          loaderEl.textContent = "Error: " + err.message;
        } finally {
          // UI State Update: Finished/Stopped
          generatePromise = null;
          generateBtn.disabled = false;
          stopBtn.hidden = true;
          bottomStopBtn.hidden = true;
          continueBtn.disabled = false;
          bottomContinueBtn.disabled = false;
          retryBtn.disabled = false;
          responseEl.readOnly = false;
          responseDeleteBtn.disabled = false;
          loaderEl.textContent = "";
          localStorage.response = responseEl.value;
        }
      }

      function startGenerate() {
        // Save current output before starting new generation for retry functionality
        savedOutputBeforeGenerate = responseEl.value;
        responseEl.value = "";
        generate();
      }

      function retryGenerate() {
        // Restore output from before last generate and regenerate
        responseEl.value = savedOutputBeforeGenerate || "";
        generate();
      }

      function stopGeneration() {
        if (generatePromise && typeof generatePromise.stop === "function") {
          generatePromise.stop();
        }
      }

      function handleDelete() {
        if (responseDeleteBtn.dataset.mode === "undo") {
          // Restore deleted content
          responseEl.value = window.deletedResponse || "";
          responseDeleteBtn.textContent = "Delete output";
          responseDeleteBtn.dataset.mode = "delete";
        } else {
          // Delete content and save for undo
          if (!stopBtn.hidden) stopBtn.click(); // Stop if generating
          window.deletedResponse = responseEl.value;
          responseEl.value = "";
          responseDeleteBtn.textContent = "Undo delete";
          responseDeleteBtn.dataset.mode = "undo";
        }
        localStorage.response = responseEl.value;

        // Update button states
        const hasOutput = responseEl.value.trim() !== "";
        continueBtn.disabled = !hasOutput;
        bottomContinueBtn.disabled = !hasOutput;
        retryBtn.disabled = !hasOutput;
        responseDeleteBtn.hidden = !hasOutput && responseDeleteBtn.dataset.mode === "delete";
      }

      // Event Listeners
      stopBtn.onclick = stopGeneration;
      bottomStopBtn.onclick = stopGeneration;

      customInstructionEl.addEventListener("input", () => {
        localStorage.customInstruction = customInstructionEl.value;
        updateInstruction();
      });

      inputTextEl.addEventListener("input", updateInstruction);

      // Initialize delete button dataset
      responseDeleteBtn.dataset.mode = "delete";

      selectAllBtn.onclick = () => setSelectedModes(modesData.map((m) => m.name));
      clearAllBtn.onclick = () => setSelectedModes([]);

      // Initialize
      buildModeGrid();
      loadSaved();
      renderSelection();
      updateInstruction();
    </script>
  </body>
</html>
